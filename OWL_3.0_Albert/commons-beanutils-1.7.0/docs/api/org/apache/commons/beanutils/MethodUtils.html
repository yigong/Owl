<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN""http://www.w3.org/TR/REC-html40/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc on Sun Aug 01 21:54:58 BST 2004 -->
<TITLE>
MethodUtils (Bean Introspection Utilities (Version 1.7))
</TITLE>
<META NAME="keywords" CONTENT="org.apache.commons.beanutils.MethodUtils,MethodUtils class">
<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../../stylesheet.css" TITLE="Style">
</HEAD>
<SCRIPT>
function asd()
{
parent.document.title="MethodUtils (Bean Introspection Utilities (Version 1.7))";
}
</SCRIPT>
<BODY BGCOLOR="white" onload="asd();">

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_top"><!-- --></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../org/apache/commons/beanutils/MappedPropertyDescriptor.html"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../../org/apache/commons/beanutils/MethodUtils.MethodDescriptor.html"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="MethodUtils.html" TARGET="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;
<SCRIPT>
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html" TARGET=""><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
<A HREF="../../../../allclasses-noframe.html" TARGET=""><B>All Classes</B></A>
</NOSCRIPT>
</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;<A HREF="#nested_class_summary">NESTED</A>&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
org.apache.commons.beanutils</FONT>
<BR>
Class MethodUtils</H2>
<PRE>
java.lang.Object
  |
  +--<B>org.apache.commons.beanutils.MethodUtils</B>
</PRE>
<HR>
<DL>
<DT>public class <B>MethodUtils</B><DT>extends java.lang.Object</DL>

<P>
<p> Utility reflection methods focussed on methods in general rather than properties in particular. </p>

 <h3>Known Limitations</h3>
 <h4>Accessing Public Methods In A Default Access Superclass</h4>
 <p>There is an issue when invoking public methods contained in a default access superclass.
 Reflection locates these methods fine and correctly assigns them as public.
 However, an <code>IllegalAccessException</code> is thrown if the method is invoked.</p>

 <p><code>MethodUtils</code> contains a workaround for this situation. 
 It will attempt to call <code>setAccessible</code> on this method.
 If this call succeeds, then the method can be invoked as normal.
 This call will only succeed when the application has sufficient security privilages. 
 If this call fails then a warning will be logged and the method may fail.</p>
<P>

<P>
<DL>
<DT><B>Author:</B></DT>
  <DD>Craig R. McClanahan, Ralph Schaer, Chris Audley, Rey François, Gregor Raýman, Jan Sorensen, Robert Burrell Donkin</DD>
</DL>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->

<A NAME="nested_class_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Nested Class Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private static&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/commons/beanutils/MethodUtils.MethodDescriptor.html">MethodUtils.MethodDescriptor</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Represents the key to looking up a Method by reflection.</TD>
</TR>
</TABLE>
&nbsp;
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Field Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private static&nbsp;java.util.WeakHashMap</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/commons/beanutils/MethodUtils.html#cache">cache</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stores a cache of Methods against MethodDescriptors, in a WeakHashMap.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private static&nbsp;java.lang.Class[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/commons/beanutils/MethodUtils.html#emptyClassArray">emptyClassArray</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;An empty class array</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private static&nbsp;java.lang.Object[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/commons/beanutils/MethodUtils.html#emptyObjectArray">emptyObjectArray</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;An empty object array</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private static&nbsp;org.apache.commons.logging.Log</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/commons/beanutils/MethodUtils.html#log">log</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;All logging goes through this logger</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/commons/beanutils/MethodUtils.html#loggedAccessibleWarning">loggedAccessibleWarning</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Only log warning about accessibility work around once</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../../org/apache/commons/beanutils/MethodUtils.html#MethodUtils()">MethodUtils</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Method Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.reflect.Method</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/commons/beanutils/MethodUtils.html#getAccessibleMethod(java.lang.Class, java.lang.String, java.lang.Class)">getAccessibleMethod</A></B>(java.lang.Class&nbsp;clazz,
                    java.lang.String&nbsp;methodName,
                    java.lang.Class&nbsp;parameterType)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return an accessible method (that is, one that can be invoked via
 reflection) with given name and a single parameter.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.reflect.Method</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/commons/beanutils/MethodUtils.html#getAccessibleMethod(java.lang.Class, java.lang.String, java.lang.Class[])">getAccessibleMethod</A></B>(java.lang.Class&nbsp;clazz,
                    java.lang.String&nbsp;methodName,
                    java.lang.Class[]&nbsp;parameterTypes)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return an accessible method (that is, one that can be invoked via
 reflection) with given name and parameters.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.reflect.Method</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/commons/beanutils/MethodUtils.html#getAccessibleMethod(java.lang.reflect.Method)">getAccessibleMethod</A></B>(java.lang.reflect.Method&nbsp;method)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return an accessible method (that is, one that can be invoked via
 reflection) that implements the specified Method.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private static&nbsp;java.lang.reflect.Method</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/commons/beanutils/MethodUtils.html#getAccessibleMethodFromInterfaceNest(java.lang.Class, java.lang.String, java.lang.Class[])">getAccessibleMethodFromInterfaceNest</A></B>(java.lang.Class&nbsp;clazz,
                                     java.lang.String&nbsp;methodName,
                                     java.lang.Class[]&nbsp;parameterTypes)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return an accessible method (that is, one that can be invoked via
 reflection) that implements the specified method, by scanning through
 all implemented interfaces and subinterfaces.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.reflect.Method</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/commons/beanutils/MethodUtils.html#getMatchingAccessibleMethod(java.lang.Class, java.lang.String, java.lang.Class[])">getMatchingAccessibleMethod</A></B>(java.lang.Class&nbsp;clazz,
                            java.lang.String&nbsp;methodName,
                            java.lang.Class[]&nbsp;parameterTypes)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Find an accessible method that matches the given name and has compatible parameters.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/commons/beanutils/MethodUtils.html#getPrimitiveType(java.lang.Class)">getPrimitiveType</A></B>(java.lang.Class&nbsp;wrapperType)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the class for the primitive type corresponding to the primitive wrapper class given.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/commons/beanutils/MethodUtils.html#getPrimitiveWrapper(java.lang.Class)">getPrimitiveWrapper</A></B>(java.lang.Class&nbsp;primitiveType)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the wrapper object class for the given primitive type class.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/commons/beanutils/MethodUtils.html#invokeExactMethod(java.lang.Object, java.lang.String, java.lang.Object)">invokeExactMethod</A></B>(java.lang.Object&nbsp;object,
                  java.lang.String&nbsp;methodName,
                  java.lang.Object&nbsp;arg)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Invoke a method whose parameter type matches exactly the object
 type.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/commons/beanutils/MethodUtils.html#invokeExactMethod(java.lang.Object, java.lang.String, java.lang.Object[])">invokeExactMethod</A></B>(java.lang.Object&nbsp;object,
                  java.lang.String&nbsp;methodName,
                  java.lang.Object[]&nbsp;args)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Invoke a method whose parameter types match exactly the object
 types.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/commons/beanutils/MethodUtils.html#invokeExactMethod(java.lang.Object, java.lang.String, java.lang.Object[], java.lang.Class[])">invokeExactMethod</A></B>(java.lang.Object&nbsp;object,
                  java.lang.String&nbsp;methodName,
                  java.lang.Object[]&nbsp;args,
                  java.lang.Class[]&nbsp;parameterTypes)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Invoke a method whose parameter types match exactly the parameter
 types given.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/commons/beanutils/MethodUtils.html#invokeMethod(java.lang.Object, java.lang.String, java.lang.Object)">invokeMethod</A></B>(java.lang.Object&nbsp;object,
             java.lang.String&nbsp;methodName,
             java.lang.Object&nbsp;arg)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Invoke a named method whose parameter type matches the object type.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/commons/beanutils/MethodUtils.html#invokeMethod(java.lang.Object, java.lang.String, java.lang.Object[])">invokeMethod</A></B>(java.lang.Object&nbsp;object,
             java.lang.String&nbsp;methodName,
             java.lang.Object[]&nbsp;args)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Invoke a named method whose parameter type matches the object type.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/commons/beanutils/MethodUtils.html#invokeMethod(java.lang.Object, java.lang.String, java.lang.Object[], java.lang.Class[])">invokeMethod</A></B>(java.lang.Object&nbsp;object,
             java.lang.String&nbsp;methodName,
             java.lang.Object[]&nbsp;args,
             java.lang.Class[]&nbsp;parameterTypes)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Invoke a named method whose parameter type matches the object type.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/commons/beanutils/MethodUtils.html#isAssignmentCompatible(java.lang.Class, java.lang.Class)">isAssignmentCompatible</A></B>(java.lang.Class&nbsp;parameterType,
                       java.lang.Class&nbsp;parameterization)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Determine whether a type can be used as a parameter in a method invocation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/apache/commons/beanutils/MethodUtils.html#toNonPrimitiveClass(java.lang.Class)">toNonPrimitiveClass</A></B>(java.lang.Class&nbsp;clazz)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Find a non primitive representation for given primitive class.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from class java.lang.Object</B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Field Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="log"><!-- --></A><H3>
log</H3>
<PRE>
private static org.apache.commons.logging.Log <B>log</B></PRE>
<DL>
<DD>All logging goes through this logger
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="loggedAccessibleWarning"><!-- --></A><H3>
loggedAccessibleWarning</H3>
<PRE>
private static boolean <B>loggedAccessibleWarning</B></PRE>
<DL>
<DD>Only log warning about accessibility work around once
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="emptyClassArray"><!-- --></A><H3>
emptyClassArray</H3>
<PRE>
private static final java.lang.Class[] <B>emptyClassArray</B></PRE>
<DL>
<DD>An empty class array
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="emptyObjectArray"><!-- --></A><H3>
emptyObjectArray</H3>
<PRE>
private static final java.lang.Object[] <B>emptyObjectArray</B></PRE>
<DL>
<DD>An empty object array
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="cache"><!-- --></A><H3>
cache</H3>
<PRE>
private static java.util.WeakHashMap <B>cache</B></PRE>
<DL>
<DD>Stores a cache of Methods against MethodDescriptors, in a WeakHashMap.
<P>
<DL>
</DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="MethodUtils()"><!-- --></A><H3>
MethodUtils</H3>
<PRE>
public <B>MethodUtils</B>()</PRE>
<DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Method Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="invokeMethod(java.lang.Object, java.lang.String, java.lang.Object)"><!-- --></A><H3>
invokeMethod</H3>
<PRE>
public static java.lang.Object <B>invokeMethod</B>(java.lang.Object&nbsp;object,
                                            java.lang.String&nbsp;methodName,
                                            java.lang.Object&nbsp;arg)
                                     throws java.lang.NoSuchMethodException,
                                            java.lang.IllegalAccessException,
                                            java.lang.reflect.InvocationTargetException</PRE>
<DL>
<DD><p>Invoke a named method whose parameter type matches the object type.</p>

 <p>The behaviour of this method is less deterministic 
 than <A HREF="../../../../org/apache/commons/beanutils/MethodUtils.html#invokeExactMethod(java.lang.Object, java.lang.String, java.lang.Object)"><CODE>invokeExactMethod(java.lang.Object, java.lang.String, java.lang.Object)</CODE></A>. 
 It loops through all methods with names that match
 and then executes the first it finds with compatable parameters.</p>

 <p>This method supports calls to methods taking primitive parameters 
 via passing in wrapping classes. So, for example, a <code>Boolean</code> class
 would match a <code>boolean</code> primitive.</p>

 <p> This is a convenient wrapper for
 <A HREF="../../../../org/apache/commons/beanutils/MethodUtils.html#invokeMethod(java.lang.Object, java.lang.String, java.lang.Object[])"><CODE>invokeMethod(Object object,String methodName,Object [] args)</CODE></A>.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>object</CODE> - invoke method on this object<DD><CODE>methodName</CODE> - get method with this name<DD><CODE>arg</CODE> - use this argument
<DT><B>Throws:</B>
<DD><CODE>java.lang.NoSuchMethodException</CODE> - if there is no such accessible method
<DD><CODE>java.lang.reflect.InvocationTargetException</CODE> - wraps an exception thrown by the
  method invoked
<DD><CODE>java.lang.IllegalAccessException</CODE> - if the requested method is not accessible
  via reflection</DL>
</DD>
</DL>
<HR>

<A NAME="invokeMethod(java.lang.Object, java.lang.String, java.lang.Object[])"><!-- --></A><H3>
invokeMethod</H3>
<PRE>
public static java.lang.Object <B>invokeMethod</B>(java.lang.Object&nbsp;object,
                                            java.lang.String&nbsp;methodName,
                                            java.lang.Object[]&nbsp;args)
                                     throws java.lang.NoSuchMethodException,
                                            java.lang.IllegalAccessException,
                                            java.lang.reflect.InvocationTargetException</PRE>
<DL>
<DD><p>Invoke a named method whose parameter type matches the object type.</p>

 <p>The behaviour of this method is less deterministic 
 than <A HREF="../../../../org/apache/commons/beanutils/MethodUtils.html#invokeExactMethod(java.lang.Object, java.lang.String, java.lang.Object[])"><CODE>invokeExactMethod(Object object,String methodName,Object [] args)</CODE></A>. 
 It loops through all methods with names that match
 and then executes the first it finds with compatable parameters.</p>

 <p>This method supports calls to methods taking primitive parameters 
 via passing in wrapping classes. So, for example, a <code>Boolean</code> class
 would match a <code>boolean</code> primitive.</p>

 <p> This is a convenient wrapper for
 <A HREF="../../../../org/apache/commons/beanutils/MethodUtils.html#invokeMethod(java.lang.Object, java.lang.String, java.lang.Object[], java.lang.Class[])"><CODE>invokeMethod(Object object,String methodName,Object [] args,Class[] parameterTypes)</CODE></A>.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>object</CODE> - invoke method on this object<DD><CODE>methodName</CODE> - get method with this name<DD><CODE>args</CODE> - use these arguments - treat null as empty array
<DT><B>Throws:</B>
<DD><CODE>java.lang.NoSuchMethodException</CODE> - if there is no such accessible method
<DD><CODE>java.lang.reflect.InvocationTargetException</CODE> - wraps an exception thrown by the
  method invoked
<DD><CODE>java.lang.IllegalAccessException</CODE> - if the requested method is not accessible
  via reflection</DL>
</DD>
</DL>
<HR>

<A NAME="invokeMethod(java.lang.Object, java.lang.String, java.lang.Object[], java.lang.Class[])"><!-- --></A><H3>
invokeMethod</H3>
<PRE>
public static java.lang.Object <B>invokeMethod</B>(java.lang.Object&nbsp;object,
                                            java.lang.String&nbsp;methodName,
                                            java.lang.Object[]&nbsp;args,
                                            java.lang.Class[]&nbsp;parameterTypes)
                                     throws java.lang.NoSuchMethodException,
                                            java.lang.IllegalAccessException,
                                            java.lang.reflect.InvocationTargetException</PRE>
<DL>
<DD><p>Invoke a named method whose parameter type matches the object type.</p>

 <p>The behaviour of this method is less deterministic 
 than <A HREF="../../../../org/apache/commons/beanutils/MethodUtils.html#invokeExactMethod(java.lang.Object, java.lang.String, java.lang.Object[], java.lang.Class[])"><CODE>invokeExactMethod(Object object,String methodName,Object [] args,Class[] parameterTypes)</CODE></A>. 
 It loops through all methods with names that match
 and then executes the first it finds with compatable parameters.</p>

 <p>This method supports calls to methods taking primitive parameters 
 via passing in wrapping classes. So, for example, a <code>Boolean</code> class
 would match a <code>boolean</code> primitive.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>object</CODE> - invoke method on this object<DD><CODE>methodName</CODE> - get method with this name<DD><CODE>args</CODE> - use these arguments - treat null as empty array<DD><CODE>parameterTypes</CODE> - match these parameters - treat null as empty array
<DT><B>Throws:</B>
<DD><CODE>java.lang.NoSuchMethodException</CODE> - if there is no such accessible method
<DD><CODE>java.lang.reflect.InvocationTargetException</CODE> - wraps an exception thrown by the
  method invoked
<DD><CODE>java.lang.IllegalAccessException</CODE> - if the requested method is not accessible
  via reflection</DL>
</DD>
</DL>
<HR>

<A NAME="invokeExactMethod(java.lang.Object, java.lang.String, java.lang.Object)"><!-- --></A><H3>
invokeExactMethod</H3>
<PRE>
public static java.lang.Object <B>invokeExactMethod</B>(java.lang.Object&nbsp;object,
                                                 java.lang.String&nbsp;methodName,
                                                 java.lang.Object&nbsp;arg)
                                          throws java.lang.NoSuchMethodException,
                                                 java.lang.IllegalAccessException,
                                                 java.lang.reflect.InvocationTargetException</PRE>
<DL>
<DD><p>Invoke a method whose parameter type matches exactly the object
 type.</p>

 <p> This is a convenient wrapper for
 <A HREF="../../../../org/apache/commons/beanutils/MethodUtils.html#invokeExactMethod(java.lang.Object, java.lang.String, java.lang.Object[])"><CODE>invokeExactMethod(Object object,String methodName,Object [] args)</CODE></A>.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>object</CODE> - invoke method on this object<DD><CODE>methodName</CODE> - get method with this name<DD><CODE>arg</CODE> - use this argument
<DT><B>Throws:</B>
<DD><CODE>java.lang.NoSuchMethodException</CODE> - if there is no such accessible method
<DD><CODE>java.lang.reflect.InvocationTargetException</CODE> - wraps an exception thrown by the
  method invoked
<DD><CODE>java.lang.IllegalAccessException</CODE> - if the requested method is not accessible
  via reflection</DL>
</DD>
</DL>
<HR>

<A NAME="invokeExactMethod(java.lang.Object, java.lang.String, java.lang.Object[])"><!-- --></A><H3>
invokeExactMethod</H3>
<PRE>
public static java.lang.Object <B>invokeExactMethod</B>(java.lang.Object&nbsp;object,
                                                 java.lang.String&nbsp;methodName,
                                                 java.lang.Object[]&nbsp;args)
                                          throws java.lang.NoSuchMethodException,
                                                 java.lang.IllegalAccessException,
                                                 java.lang.reflect.InvocationTargetException</PRE>
<DL>
<DD><p>Invoke a method whose parameter types match exactly the object
 types.</p>

 <p> This uses reflection to invoke the method obtained from a call to
 <A HREF="../../../../org/apache/commons/beanutils/MethodUtils.html#getAccessibleMethod(java.lang.Class, java.lang.String, java.lang.Class)"><CODE>getAccessibleMethod(java.lang.Class, java.lang.String, java.lang.Class)</CODE></A>.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>object</CODE> - invoke method on this object<DD><CODE>methodName</CODE> - get method with this name<DD><CODE>args</CODE> - use these arguments - treat null as empty array
<DT><B>Throws:</B>
<DD><CODE>java.lang.NoSuchMethodException</CODE> - if there is no such accessible method
<DD><CODE>java.lang.reflect.InvocationTargetException</CODE> - wraps an exception thrown by the
  method invoked
<DD><CODE>java.lang.IllegalAccessException</CODE> - if the requested method is not accessible
  via reflection</DL>
</DD>
</DL>
<HR>

<A NAME="invokeExactMethod(java.lang.Object, java.lang.String, java.lang.Object[], java.lang.Class[])"><!-- --></A><H3>
invokeExactMethod</H3>
<PRE>
public static java.lang.Object <B>invokeExactMethod</B>(java.lang.Object&nbsp;object,
                                                 java.lang.String&nbsp;methodName,
                                                 java.lang.Object[]&nbsp;args,
                                                 java.lang.Class[]&nbsp;parameterTypes)
                                          throws java.lang.NoSuchMethodException,
                                                 java.lang.IllegalAccessException,
                                                 java.lang.reflect.InvocationTargetException</PRE>
<DL>
<DD><p>Invoke a method whose parameter types match exactly the parameter
 types given.</p>

 <p>This uses reflection to invoke the method obtained from a call to
 <A HREF="../../../../org/apache/commons/beanutils/MethodUtils.html#getAccessibleMethod(java.lang.Class, java.lang.String, java.lang.Class)"><CODE>getAccessibleMethod(java.lang.Class, java.lang.String, java.lang.Class)</CODE></A>.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>object</CODE> - invoke method on this object<DD><CODE>methodName</CODE> - get method with this name<DD><CODE>args</CODE> - use these arguments - treat null as empty array<DD><CODE>parameterTypes</CODE> - match these parameters - treat null as empty array
<DT><B>Throws:</B>
<DD><CODE>java.lang.NoSuchMethodException</CODE> - if there is no such accessible method
<DD><CODE>java.lang.reflect.InvocationTargetException</CODE> - wraps an exception thrown by the
  method invoked
<DD><CODE>java.lang.IllegalAccessException</CODE> - if the requested method is not accessible
  via reflection</DL>
</DD>
</DL>
<HR>

<A NAME="getAccessibleMethod(java.lang.Class, java.lang.String, java.lang.Class)"><!-- --></A><H3>
getAccessibleMethod</H3>
<PRE>
public static java.lang.reflect.Method <B>getAccessibleMethod</B>(java.lang.Class&nbsp;clazz,
                                                           java.lang.String&nbsp;methodName,
                                                           java.lang.Class&nbsp;parameterType)</PRE>
<DL>
<DD><p>Return an accessible method (that is, one that can be invoked via
 reflection) with given name and a single parameter.  If no such method
 can be found, return <code>null</code>.
 Basically, a convenience wrapper that constructs a <code>Class</code>
 array for you.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>clazz</CODE> - get method from this class<DD><CODE>methodName</CODE> - get method with this name<DD><CODE>parameterType</CODE> - taking this type of parameter</DL>
</DD>
</DL>
<HR>

<A NAME="getAccessibleMethod(java.lang.Class, java.lang.String, java.lang.Class[])"><!-- --></A><H3>
getAccessibleMethod</H3>
<PRE>
public static java.lang.reflect.Method <B>getAccessibleMethod</B>(java.lang.Class&nbsp;clazz,
                                                           java.lang.String&nbsp;methodName,
                                                           java.lang.Class[]&nbsp;parameterTypes)</PRE>
<DL>
<DD><p>Return an accessible method (that is, one that can be invoked via
 reflection) with given name and parameters.  If no such method
 can be found, return <code>null</code>.
 This is just a convenient wrapper for
 <A HREF="../../../../org/apache/commons/beanutils/MethodUtils.html#getAccessibleMethod(java.lang.reflect.Method)"><CODE>getAccessibleMethod(Method method)</CODE></A>.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>clazz</CODE> - get method from this class<DD><CODE>methodName</CODE> - get method with this name<DD><CODE>parameterTypes</CODE> - with these parameters types</DL>
</DD>
</DL>
<HR>

<A NAME="getAccessibleMethod(java.lang.reflect.Method)"><!-- --></A><H3>
getAccessibleMethod</H3>
<PRE>
public static java.lang.reflect.Method <B>getAccessibleMethod</B>(java.lang.reflect.Method&nbsp;method)</PRE>
<DL>
<DD><p>Return an accessible method (that is, one that can be invoked via
 reflection) that implements the specified Method.  If no such method
 can be found, return <code>null</code>.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>method</CODE> - The method that we wish to call</DL>
</DD>
</DL>
<HR>

<A NAME="getAccessibleMethodFromInterfaceNest(java.lang.Class, java.lang.String, java.lang.Class[])"><!-- --></A><H3>
getAccessibleMethodFromInterfaceNest</H3>
<PRE>
private static java.lang.reflect.Method <B>getAccessibleMethodFromInterfaceNest</B>(java.lang.Class&nbsp;clazz,
                                                                             java.lang.String&nbsp;methodName,
                                                                             java.lang.Class[]&nbsp;parameterTypes)</PRE>
<DL>
<DD><p>Return an accessible method (that is, one that can be invoked via
 reflection) that implements the specified method, by scanning through
 all implemented interfaces and subinterfaces.  If no such method
 can be found, return <code>null</code>.</p>

 <p> There isn't any good reason why this method must be private.
 It is because there doesn't seem any reason why other classes should
 call this rather than the higher level methods.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>clazz</CODE> - Parent class for the interfaces to be checked<DD><CODE>methodName</CODE> - Method name of the method we wish to call<DD><CODE>parameterTypes</CODE> - The parameter type signatures</DL>
</DD>
</DL>
<HR>

<A NAME="getMatchingAccessibleMethod(java.lang.Class, java.lang.String, java.lang.Class[])"><!-- --></A><H3>
getMatchingAccessibleMethod</H3>
<PRE>
public static java.lang.reflect.Method <B>getMatchingAccessibleMethod</B>(java.lang.Class&nbsp;clazz,
                                                                   java.lang.String&nbsp;methodName,
                                                                   java.lang.Class[]&nbsp;parameterTypes)</PRE>
<DL>
<DD><p>Find an accessible method that matches the given name and has compatible parameters.
 Compatible parameters mean that every method parameter is assignable from 
 the given parameters.
 In other words, it finds a method with the given name 
 that will take the parameters given.<p>

 <p>This method is slightly undeterminstic since it loops 
 through methods names and return the first matching method.</p>
 
 <p>This method is used by 
 <A HREF="../../../../org/apache/commons/beanutils/MethodUtils.html#invokeMethod(java.lang.Object, java.lang.String, java.lang.Object[], java.lang.Class[])"><CODE>invokeMethod(Object object,String methodName,Object [] args,Class[] parameterTypes)</CODE></A>.

 <p>This method can match primitive parameter by passing in wrapper classes.
 For example, a <code>Boolean</code> will match a primitive <code>boolean</code>
 parameter.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>clazz</CODE> - find method in this class<DD><CODE>methodName</CODE> - find method with this name<DD><CODE>parameterTypes</CODE> - find method with compatible parameters</DL>
</DD>
</DL>
<HR>

<A NAME="isAssignmentCompatible(java.lang.Class, java.lang.Class)"><!-- --></A><H3>
isAssignmentCompatible</H3>
<PRE>
public static final boolean <B>isAssignmentCompatible</B>(java.lang.Class&nbsp;parameterType,
                                                   java.lang.Class&nbsp;parameterization)</PRE>
<DL>
<DD><p>Determine whether a type can be used as a parameter in a method invocation.
 This method handles primitive conversions correctly.</p>

 <p>In order words, it will match a <code>Boolean</code> to a <code>boolean</code>,
 a <code>Long</code> to a <code>long</code>,
 a <code>Float</code> to a <code>float</code>,
 a <code>Integer</code> to a <code>int</code>,
 and a <code>Double</code> to a <code>double</code>.
 Now logic widening matches are allowed.
 For example, a <code>Long</code> will not match a <code>int</code>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameterType</CODE> - the type of parameter accepted by the method<DD><CODE>parameterization</CODE> - the type of parameter being tested
<DT><B>Returns:</B><DD>true if the assignement is compatible.</DL>
</DD>
</DL>
<HR>

<A NAME="getPrimitiveWrapper(java.lang.Class)"><!-- --></A><H3>
getPrimitiveWrapper</H3>
<PRE>
public static java.lang.Class <B>getPrimitiveWrapper</B>(java.lang.Class&nbsp;primitiveType)</PRE>
<DL>
<DD>Gets the wrapper object class for the given primitive type class.
 For example, passing <code>boolean.class</code> returns <code>Boolean.class</code>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>primitiveType</CODE> - the primitive type class for which a match is to be found
<DT><B>Returns:</B><DD>the wrapper type associated with the given primitive 
 or null if no match is found</DL>
</DD>
</DL>
<HR>

<A NAME="getPrimitiveType(java.lang.Class)"><!-- --></A><H3>
getPrimitiveType</H3>
<PRE>
public static java.lang.Class <B>getPrimitiveType</B>(java.lang.Class&nbsp;wrapperType)</PRE>
<DL>
<DD>Gets the class for the primitive type corresponding to the primitive wrapper class given.
 For example, an instance of <code>Boolean.class</code> returns a <code>boolean.class</code>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>wrapperType</CODE> - the
<DT><B>Returns:</B><DD>the primitive type class corresponding to the given wrapper class,
 null if no match is found</DL>
</DD>
</DL>
<HR>

<A NAME="toNonPrimitiveClass(java.lang.Class)"><!-- --></A><H3>
toNonPrimitiveClass</H3>
<PRE>
public static java.lang.Class <B>toNonPrimitiveClass</B>(java.lang.Class&nbsp;clazz)</PRE>
<DL>
<DD>Find a non primitive representation for given primitive class.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>clazz</CODE> - the class to find a representation for, not null
<DT><B>Returns:</B><DD>the original class if it not a primitive. Otherwise the wrapper class. Not null</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_bottom"><!-- --></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../org/apache/commons/beanutils/MappedPropertyDescriptor.html"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../../org/apache/commons/beanutils/MethodUtils.MethodDescriptor.html"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="MethodUtils.html" TARGET="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;
<SCRIPT>
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html" TARGET=""><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
<A HREF="../../../../allclasses-noframe.html" TARGET=""><B>All Classes</B></A>
</NOSCRIPT>
</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;<A HREF="#nested_class_summary">NESTED</A>&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>
Copyright (c) 2001-2004 - Apache Software Foundation
</BODY>
</HTML>
